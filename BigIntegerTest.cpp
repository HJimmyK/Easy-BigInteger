/*
MIT License

Copyright (c) 2024-2050 Twilight-Dream & With-Sky

https://github.com/Twilight-Dream-Of-Magic/
https://github.com/With-Sky

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#include "BigIntegerTest.hpp"

namespace TwilightDream::BigInteger::Test
{
	inline void test_binary_inout()
	{
		std::string s = "1011001111000011111111000000001111111111111111000000000000000011111111";
		BigInteger	b( s, 2 );
		auto		s_out = b.ToBinaryString( s.size() );
		std::cout << std::boolalpha << ( s == s_out ) << "\n";
	}

	inline void test_shift()
	{
		std::string s = "1011001111000011111111000000001111111111111111000000000000000011111111";
		BigInteger	b( s, 2 );
		b.PrintBinary();
		BigInteger a = b.LeftShiftBit( 127 );
		a.PrintBinary();
		a = a.RightShiftBit( 127 );
		a.PrintBinary();
		std::cout << std::boolalpha << ( a == b ) << "\n";
	}

	inline void test_squeeze_leading_bits()
	{
		BigInteger b = BigInteger::RandomGenerateNBit( 200 );
		b.PrintBinary();
		b.SqueezeLeadingBits( 128 );
		b.PrintBinary();
		std::cout << std::boolalpha << ( b.BitLength() <= 128 ) << "\n";
	}
	inline void test_binary_and_or_not()
	{
		{
			std::string s = "11111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000";
			BigInteger	a( s, 2 );
			a = ~a;
			std::cout << std::boolalpha << ( a.ToString( 2 ) == "1111111111111111111111111111111111111111111111111111111111111111" ) << "\n";
		}
		{
			std::string s1 = "1111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000";
			std::string s2 = "11111111111111111111111111111111111111111111110000000000000000000000001111111111100000000000000000000000000000000011111111111111111111111111111";
			BigInteger	a( s1, 2 ), b( s2, 2 );
			a |= b;
			std::cout << std::boolalpha << ( a.ToString( 2 ) == "11111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000011111111111111111111111111111" ) << "\n";
		}
		{
			std::string s1 = "1111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000";
			std::string s2 = "11111111111111111111111111111111111111111111110000000000000000000000001111111111100000000000000000000000000000000011111111111111111111111111111";
			BigInteger	a( s1, 2 ), b( s2, 2 );
			a &= b;
			std::cout << std::boolalpha << ( a.ToString( 2 ) == "1111111110000000000000000000000000000000000000000000000000000000000000000" ) << "\n";
		}
		{
			std::string s1 = "1111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000";
			std::string s2 = "11111111111111111111111111111111111111111111110000000000000000000000001111111111100000000000000000000000000000000011111111111111111111111111111";
			BigInteger	a( s1, 2 ), b( s2, 2 );
			a ^= b;
			std::cout << std::boolalpha << ( a.ToString( 2 ) == "11111111111111111111111111111111111111111111111111111111111111111111110000000001100000000000000000000000000000000011111111111111111111111111111" ) << "\n";
		}
	}

	inline void test_rotate_shift()
	{
		std::string s = "11111111111111111111111111111111111111111111111111111111111111110110110000000000000000000000000000101100111100001111111100000110";
		BigInteger	a( s, 2 );
		a = BigInteger::BitRotateRight( a, 13, 64 );  //前64个bit循环移动13位
		a.PrintBinary();
		a = BigInteger::BitRotateLeft( a, 13, 64 );
		std::cout << std::boolalpha << ( a.ToString( 2 ) == s ) << "\n";

		a = BigInteger::BitRotateRight( a, 72, 128 );  //前128个bit循环移动72位
		a.PrintBinary();
		a = BigInteger::BitRotateLeft( a, 72, 128 );
		std::cout << std::boolalpha << ( a.ToString( 2 ) == s ) << "\n";

		a = BigInteger::BitRotateRight( a, 72, 256 );  //前256个bit循环移动72位
		a.PrintBinary();
		a = BigInteger::BitRotateLeft( a, 72, 256 );
		std::cout << std::boolalpha << ( a.ToString( 2 ) == s ) << "\n";
	}

	inline void test_str_inout()
	{
		{
			std::string s2 = "1011001111000011111111000000001111111111111111000000000000000011111111";
			BigInteger	b( s2, 2 );
			b.PrintBinary();
			auto s_out = b.ToString( 2 );
			std::cout << s2 << "\n";
			std::cout << s_out << "\n";
			std::cout << std::boolalpha << ( s2 == s_out ) << "\n";
		}
		{
			std::string s10 = "123456789123456789123456789123456789123456789123456789123456789123456789123456789";
			BigInteger	b( s10, 10 );
			b.PrintBinary();
			auto s_out = b.ToString( 10 );
			std::cout << s10 << "\n";
			std::cout << s_out << "\n";
			std::cout << std::boolalpha << ( s10 == s_out ) << "\n";
		}
		{
			std::string s16 = "1234567891234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890";
			BigInteger	b( s16, 16 );
			b.PrintBinary();
			auto s_out = b.ToString( 16 );
			std::cout << s16 << "\n";
			std::cout << s_out << "\n";
			std::cout << std::boolalpha << ( s16 == s_out ) << "\n";
		}
		{
			std::string s36 = "1234567891234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567891234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ";
			BigInteger	b( s36, 36 );
			b.PrintBinary();
			auto s_out = b.ToString( 36 );
			std::cout << s36 << "\n";
			std::cout << s_out << "\n";
			std::cout << std::boolalpha << ( s36 == s_out ) << "\n";
		}
	}

	inline void test_addition()
	{
		{
			std::string s = "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999";
			BigInteger	a( s, 10 );
			BigInteger	b( s, 10 );

			a = a + b;

			std::cout << std::boolalpha << ( a.ToString( 10 ) == "19999999999999999999999999999999999999999999999999999999999999999999999999999999999998" ) << "\n";
		}
		{
			std::string s = "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999";
			BigInteger	a( s, 10 );
			BigInteger	b = 1;

			a = a + b;

			std::cout << std::boolalpha << ( a.ToString( 10 ) == "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000" ) << "\n";
		}
	}

	inline void test_substraction()
	{
		{
			std::string s = "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
			BigInteger	a( s, 10 );
			BigInteger	b = 9;

			a = a - b;

			std::cout << std::boolalpha << ( a.ToString( 10 ) == "99999999999999999999999999999999999999999999999999999999999999999999999999999999999991" ) << "\n";
		}
		{
			std::string s = "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999";
			BigInteger	a( s, 10 );
			BigInteger	b( s, 36 );

			a = a + b;
			a = a - b;

			std::cout << std::boolalpha << ( a.ToString( 10 ) == s ) << "\n";
		}
	}

	inline void test_multiplication()
	{
		size_t		len = 10000;
		std::string s1( len, '9' );
		std::string s2( len, '7' );
		BigInteger	a( s1, 10 );
		BigInteger	b( s2, 10 );
		auto		t1 = std::chrono::high_resolution_clock::now();
		BigInteger	c = a * b;
		auto		t2 = std::chrono::high_resolution_clock::now();
		std::cout << std::boolalpha << ( c.ToString( 10 ) == ( std::string( len - 1, '7' ) + '6' + std::string( len - 1, '2' ) + '3' ) ) << "\n";
		std::cout << std::chrono::duration_cast<std::chrono::microseconds>( t2 - t1 ).count() << "us\n";
	}

	inline void test_reciprocal_newton()
	{
		std::string s = "10081865862302450901048126245498057221231100426283198514243987837404638254564912856160563991450848317969719767784193179593685135677108759644146435914627965177462467236493310242576614724377894349862837931397688168687922474548031752832531976879685319615341494383421024637358213722804970566320075038090872";
		BigInteger	x( s, 10 );
		size_t		n = 6400;
		x = x.ReciprocalNewtonIteration( n );
		std::string s_new = "10001000000010100001011001010111100100101001001001011100010110000000110100010101110011100101100111100011001101110110101110110100000111001101111010101100001011100000101011000101101010101100010110011001001101011000110110101001010101110001100011011100100101100110001001111010000011001000000010100000000111110110010001000110010001110101000101100101100111101011101001010010010001000000111011011001100011001001000111111101111110001001001100110100101011000110000000100110101010101010110011011110010000110110100101010000010010011010101011101011111101001010001000010110000010010000000100011001111010100000110001111011101011110011110110011100000110111000111101111101001010101011100010111011001001011100101101001001100010010100111100110111110010000010001110111101011000100000101110000110111001100110101100011100001000001001010101100101111001110101011100010101101110110111111001000000110101010010001010001110110001001000110010111100011111001100111011100100110101101111100011001010101011100000111111110110000101010001000010011001100100110010001100101010110001100100101000111101001101001000001011011111011011000011010001010110110100001101010010100101001000000101110111111100100101011000101100110111011110100110100100011010011100010101010111100110001001111001111011001100001111011011101010111100010010011100100100010111001000101001001010110111011001010000110101010010010100000000101110111010000001111110000000111001100001111100011001011100000000000110011000011010001101110000000110110111001001110111000010000110000100000010100100000111010000001101010110101101100111101001101010100001100000010110011111111000111110101111110100011110010101110100100110010011001010101101000001011110110101001011011001100111110111111100011100101111100100110000101111101010000101100000111101110101001010000110100111011111110000011010100010011001000100010111000111101101111100000100100010110101011000010100011010001110010111011000101101000110111000110101110111101100100011001000011001110101010111000110100111101101100000110101110110010000101011100101000010101001000111000011011001000011101100010011100101111011110011000111001101100110001111011001010111111110111110111010010111010011110011101100101010101001110001011011100110101010001000110010001111111001111100100010110010100011000001111111000000110000001010111100001101010010110111111011010000111100111010100001011101110100000111111011011000011000100001101100000010010101001011000000001111110101110000100100110100101111100100001001010111111110000111010101001110011100010010101010000110101010011110101100001011100011010110000110000010000101110000110000101011011000101011011001110001001110001000011001001010011011110001100010110001101110010110110001010100000000110111000110001100111101111111110011111111001110000000101011000010011000100110110001101010101110100100000100110011000101011000101001000100001011010111000000111010100101111010101011000001011010000001101001110010010100110101000011000101111100110010110011101000011111101110101100101100100100010111000010110101100000111110001101111010000110111001001001100111001110110011011100011010111001000110010000011101010001011010001111101001101011010100100000001101011111000111001111110010011111110010100000110010"
							"00110010000110010100101101010110010001110011011000100111111101100100011111111100010101000100101110001011101011101000110001101100110100011011010111110100001001011100101111100110100110011101101101111010110111010100001100011011100101101011100110010010001010111001010111100100101001010100010001110110001001000100111011000001100110101000011010101101011100110001011000100110111001010000010111101000000101011111100001100100011100011000010011000111000011101110001000011110001001101010111001101100101101000111000010111110101000101010010011111000010100000110100100000101000010110110001001000110110001101110100101010010101000101110000001001101010001101100010011111101001011100101111010000010000100010011111101101101110010100011011110001101010011000010011011100000000100100101011101010011011011001011110000110110101100110100111010001111101100011101100001000011010111101110001001000011111010011000001111100011111101011100101111110000111010001001100100110111110101000011010111000101101101001010011100001001010001000111010001101010111100101000100111111000100010010011110001011010010100010110101001110111010101010010101111001111000111011101110011000101111100100010001100001011011000110101000100101000110111011010001111001010101011010101101111010010001000101001100011010011011100111011010100000110110110110111001000001010011001110100100010100001011010010010000001100000011001110000000010111110011111010010001011000110011101010110000000011100001111010100111011011001010001100001011100111001111100010110111110100100010101011000100100010011010100001000101000000001101011110110001000010010010110000010110110001101110010001100111110100000110001001110000101010011011111110010010110101111101000000011100001110101100001100100111101101100101011101101011010000100111010000101111110111110000000110111001110101000010000001110001001010111100011111100110100000000011110110100101000111001011101111110000010011001101110001011001010011110100011010011010111111000110011010111111101101011100101100010101101000101001110000000001010100001111111010010010101011100010110001110001001100110111110100000111100111111110010101011101111100101001011000111010111001100111110010011000100011001101100100000111010000010000001001100000001000101011000001111101001000101101010010010100";
		//x.PrintBinary();
		std::cout << std::boolalpha << ( x.ToString( 2 ) == s_new ) << "\n";
	}

	inline void test_division_number()
	{
		size_t	   n = 6400;
		BigInteger x = BigInteger::TwoPowerN( n );
		x.DividModuloNumber( 100818658 );
		std::string s = x.ToString( 2 );
		bool		ok = s
			== "101010100110011101010110110100101101111110110010000011010010110001000101100110000101110010100110000001111000011111101110111011011011110000001101001010010111100010110011100111000110000011100000011011111101110110000010011110110100001100101011101100100011010111101101100000001011001001000111101110100010001100000010011101111000101011001110101001011011011011100001110011000101011100101000100011000010110110111010101010101010000000110111101011110001111110110111000011011100011110100001001101100101101110000000001111000100011100000100011100100010000101010001011001010101000101100010010100010011110001111011110110011110011101111001010010000001011110110110010111101110010010111010011101101100011110110011101111000000101000001000101101010001011010011011011011111010111010111011111101100111011101110000010001111100101101111100110100100010010110111001100001111001010111100000010000001100111001101111101011111000111111111000000010001111010110100011000110101000001000110101101110100100111110010110110110100111000010011111011011010011001001110110000001100101100000100001101000010001100100101001000010010111000011100111011001100110110100110101100000100111110010100101010010100111001010100100001001100101111010110101101001111011101011000011101000110000000010010010011101010010001000111100111011001001011110110001010101110110000101101110101100111111110100001000101100000000001001000111110111101010010010010101111110010100011111101010111100101011100101010101110101010011001101000001101111011101101011000001110000100101111001111001001000001111101000101010110010000101000000000010010010110101001010011100101010000101111100110000010101101001011100001110111111101101101110010011110111110000010011101011111010010011001110011101111111010110100000011100010011101000001110000110100011101000111110011111101100011000011111001011101000110000001100001110110011110000101001111000011001111111010010011010100010001011010101010011101011011111100100001100110011111010001010000111101010001110010110111100110110000000011010100110111011000111111101110111100101000110011010000110000011001011000111101111010000111100000101100101101110101011111000000101111000110000110100111000101101011010111001001111011111110101001001100111011011000001001001111010011110011010000010101001000011010101010011011101111000111010001100110101011100101110011000100011010011000011011001100111101001111100010000111001111001011111001111000001111111101110111000110110001011001110100011111010001001000101110110000011110000010100001001011110000011000010000101100000011000010110010110111001110111100101111001000001000110000111001100011011111111010000010101100011111110100110110111010010001010001001100000010000000010001010001000111100000011100110111101110111111001011111011001001100010100110101000010010000111101001001111101111110011010100101001100011110001110101101100000000000110010011110100000111001101011000001001111110101001001000000001110111000111001100010101110100110111010010110010001011100011001011100011110010101010010000110011101111000001100010000010111111001011011100000101111100010000111101011010011110010110000100100010001001101110011010100000100111101011001001101100010000011011010000100110010000100001000011111000111010101010000101111001"
			   "000110101100101110011100000011110111100010011001110011110011110101000110000000000000100010101111111001101010100000011110000100010110011010110101111010101100100001000101011100010010001011010000010010010000100100110100100111110011011111000110001111000100000000001111110111000101000100010011111011011101111111100010101010111010000101000100110010011100110010011000100101101011001000011000001110101110011100110010000111101000101011101000101100111100000011010111110011010111110000101101011100001100110100100100110011001111011010111000100000001110011111111110110101100101001011110010011010000010100010010010101010101101010100000101011111001101001101000111010001110010000000011110001100100101110001011010110100011110100111010001110111010111011100010100011011110001010110000000001011000100010010101101000011101111001110100011010110000000101010010000100010110110101100001111100101001100010001011000111110101010110000000010100101100101011001001110011111101111111110101101110001100010011110010110001110011110100000001100111011011100000110100000111101010101011100110000100000001011001111000000110011111101000010100100000110111000111001010000110011000010111011100011011101010101110010010000001101100111101111110011101111110100001101010111111101001011100100101100100110100010100001001000110000100000100010111110000000000110101100110110010011100111011101100010101011111101010100011011101101111011010101110001011000101001000111000010111111010100101001100001000011011100001111110100101010011111100101000110010011111001010101000001101111001100010100101111011011011111000011111010101111111111001010110101101010101111001011010011011000001110000001011000001111000010110111110001000001010010011010000001011000100100100111011010000100010110111010110100000101111010100011010101100100110011101011010010011101101010010011100100001001111011100101101100101010101000001100010010100010000110011100011111111010010011110010011110011011101110100001000100000010111010010101100100101100110100010011001010001001100111010100010101011110110100110000110001110011000010010001110111001111100100000110001111010011101101000001111100011110111000101110011011101111100000001101110011101011100010111110010111010000101111110010100110001000011111001011010100001100111000110100011011000100111110001110000000101001100110111110111101011011010010100001100101010101011011111001000010111111001001001111010011110110010000000010001100100001010111101010101001101000100000011011001000011110111110011110011110000011100011101011001100000010101101100100001000000111001000100010001100100110000111000010000001001011110010010101100100010011111001011011010111000111001001101010111011000101000001011110001100000101100100010001000101000111110101100111001011010010110011111110111011110010001000100101000000101011010100100111001000011001001011111111000100001011110110001000011011010100100111001111001000100001011000010011010001100111101100000110000101111101010000001001001011000010111011100010101010110000000111011001000111000001001001010000010011111001111011000101010011111100101100100111011100010011011011011101000001111011100101101110010111110010101111100001000001001100010001011000001010101111111000010000110001010101010110101101011111101111000110111"
			   "00011110";
		//std::cout< <s <<"\n";
		std::cout << std::boolalpha << ok << std::endl;
	}

	inline void test_division()
	{
		auto test_func = [ = ]( auto a, auto b ) -> bool {
			auto	   t1 = std::chrono::steady_clock::now();
			BigInteger q = a / b;
			auto	   t2 = std::chrono::steady_clock::now();
			BigInteger rem = a % b;

			std::cout << std::chrono::duration_cast<std::chrono::microseconds>( t2 - t1 ).count() << "us\n";
			t1 = std::chrono::steady_clock::now();
			BigInteger product = q * b;
			t2 = std::chrono::steady_clock::now();
			std::cout << std::chrono::duration_cast<std::chrono::microseconds>( t2 - t1 ).count() << "us\n";

			if ( rem + product != a )
			{
				std::cout << "case 1" << std::endl;
				return false;
			}
			if ( rem >= b )
			{
				std::cout << "case 2" << std::endl;
				return false;
			}
			return true;
		};
		size_t bit_a = 4096, bit_b = 2048;

		BigInteger a = BigInteger::RandomGenerateNBit( bit_a );
		BigInteger b = BigInteger::RandomGenerateNBit( bit_b );
		std::cout << std::boolalpha << test_func( a, b ) << std::endl;
	}

	inline void test_gcd()
	{
		BigInteger BigIntA( "349361082127915121481755525862885131460681137789444699486415082992927313462561499429886387374963185099249239319346364035212576264619573389313644070717554860108877561182863814295465419073875768938725210027008017671639683276632859159399899057779617092704962451010743886930123219991195386804295974469217078569659205644179468716262444595849327286918958122806957275529672871634095894038652361443854466535681762226299832766563655807662005746948033363876637278855951958107697429405120776688589651270725535303235692847490458004744327203402338802325334816752154499341083507009511988910715249273543241644014852457128515239452097136180636869652792356311678837460350910906901565645379859426060839351819246541164223381436338932257100429097195996584718397765641623368875443685630742472072398838879278828219131356240676050956580827649052044946905066469834498449098364994260808941014399855329928464877029852610713220801286362487013463625830421049252528590705422769481870838409366855322030838803282946090736969999504182098987639169374062350689143073322575331893077895637881747994673299440419066223745994683891803999886565489810868642299899474338087614281783532952935925690051017993803614997833360819436369538148726630126514704041287324429301046630523", 10 );
		BigInteger BigIntB( "3312186834341286011770497254354946449520542237529621050345613876960648152623397989718785315994864353500343837769320096498729184068052393274554511738843739580764460396294101324815831975401860205998154509725117106006118793969268669631418277493779585934723324674079994291219791243885780198919409680145485168369640636165472208154579380286440526826408994836720166966458810985629766274053688260249094829782338624360434959354041555778283400054153285903115516599130706551423704166862548822469000343866854351019435091130262953811456171128395957460260641302274691920810256537861637442746759758089447004405793466207625615070184311310180259760476203880020649650844301625937981575278371486281473915764982479073997792705927937226243680878802564598737903098156182997407260408029920793845120252510245942674043685252009145257059272695141972083056817446395078757783231897185292954505601783099863480154689296980328197177161949115185885520728711091470951921995617917573069579682364517786546124654804014954022871310238698376369352902123274505684601248597076960097771664110328616937687589181484620947214164086651596228042525252403419943330049546549409178739201097346188388064228365534417657480003346210427666705606158934010453915859208561594123422244203816", 10 );

		BigIntA.PrintBinary( true );
		BigIntB.PrintBinary( true );

		auto BigInt_GCD = BigInteger::GCD( BigIntA, BigIntB );
		std::cout << BigInt_GCD.ToString( 10 );
	}

	inline void test_exgcd()
	{
		BigSignedInteger a( "25398085575060084225404954746388476681079750131800006062182993208094723176121664212055763070910911294169275160911859330588831293065333710893391556909162805666214067874743106014965110446065795040181479508881959094848989857154653503464905133756540194911687853648635523061327598450248561677414639419778728852396854013090405403246520108384212988529156849598807555625068631462142598339445673055170030933004338658610591351506560958125879616861949874451705678889352076512311275164200784245090303802153442138471200986525831352458591052294346574588825880470445259668010500624143068086993390717597731710878145931254772396384043" );
		BigSignedInteger b( "99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999" );
		BigSignedInteger x, y, g;
		BigSignedInteger::EGCD( a, b, g, x, y );
		std::cout << x.ToString( 10 ) << "\n";
		std::cout << y.ToString( 10 ) << "\n";
		std::cout << g.ToString( 10 ) << "\n";
	}

	inline void test_modulo_inverse()
	{

		//Z_{p}
		//b = a * k (mod p)
		//a = b * k^{-1} (mod p)

		BigSignedInteger prime_modulo_number( "25398085575060084225404954746388476681079750131800006062182993208094723176121664212055763070910911294169275160911859330588831293065333710893391556909162805666214067874743106014965110446065795040181479508881959094848989857154653503464905133756540194911687853648635523061327598450248561677414639419778728852396854013090405403246520108384212988529156849598807555625068631462142598339445673055170030933004338658610591351506560958125879616861949874451705678889352076512311275164200784245090303802153442138471200986525831352458591052294346574588825880470445259668010500624143068086993390717597731710878145931254772396384043" );
		BigSignedInteger multiplier = BigInteger::TwoPowerN( prime_modulo_number.BitLength() - 2 );

		BigSignedInteger inverse_multiplier = BigSignedInteger::ModuloInverse( multiplier, prime_modulo_number );

		BigSignedInteger value = inverse_multiplier * multiplier % prime_modulo_number;
		std::cout << std::boolalpha << ( value.ToString( 10 ) == "1" ) << "\n";
	}

	inline void test_montgomery()
	{
		BigInteger prime_modulo_number( "25398085575060084225404954746388476681079750131800006062182993208094723176121664212055763070910911294169275160911859330588831293065333710893391556909162805666214067874743106014965110446065795040181479508881959094848989857154653503464905133756540194911687853648635523061327598450248561677414639419778728852396854013090405403246520108384212988529156849598807555625068631462142598339445673055170030933004338658610591351506560958125879616861949874451705678889352076512311275164200784245090303802153442138471200986525831352458591052294346574588825880470445259668010500624143068086993390717597731710878145931254772396384043" );
		Montgomery mont( prime_modulo_number );
		BigInteger base( 999999 );
		auto	   t1 = std::chrono::steady_clock::now();
		base = mont.Power( base, prime_modulo_number - 1 );
		auto t2 = std::chrono::steady_clock::now();
		std::cout << std::chrono::duration_cast<std::chrono::microseconds>( t2 - t1 ).count() << "us\n";
		std::string s = base.ToString( 10 );
		std::cout << std::boolalpha << ( s == "1" ) << "\n";
	}

	inline void test_power_with_modulo()
	{
		BigInteger prime_modulo_number( "25398085575060084225404954746388476681079750131800006062182993208094723176121664212055763070910911294169275160911859330588831293065333710893391556909162805666214067874743106014965110446065795040181479508881959094848989857154653503464905133756540194911687853648635523061327598450248561677414639419778728852396854013090405403246520108384212988529156849598807555625068631462142598339445673055170030933004338658610591351506560958125879616861949874451705678889352076512311275164200784245090303802153442138471200986525831352458591052294346574588825880470445259668010500624143068086993390717597731710878145931254772396384043" );
		Montgomery mont( prime_modulo_number );
		BigInteger base( 999999 );
		auto	   t1 = std::chrono::steady_clock::now();
		base.PowerWithModulo( prime_modulo_number - 1, prime_modulo_number );
		auto t2 = std::chrono::steady_clock::now();
		std::cout << std::chrono::duration_cast<std::chrono::microseconds>( t2 - t1 ).count() << "us\n";
		std::string s = base.ToString( 10 );
		std::cout << std::boolalpha << ( s == "1" ) << "\n";
	}

	inline void test_byte_export_import()
	{
		{
			std::vector<std::byte> v_in = { std::byte { CHAR_MAX }, std::byte { 255 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 1 } };
			BigInteger			   n;
			n.ImportData( v_in, false );
			n.PrintBinary();
			std::vector<std::byte> v_out;
			n.ExportData( v_out, v_in.size(), false );
			std::cout << std::boolalpha << ( v_out == v_in ) << "\n";
		}
		{
			std::vector<std::byte> v_in = { std::byte { CHAR_MAX }, std::byte { 255 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 0 }, std::byte { 1 } };
			BigInteger			   n;
			n.ImportData( v_in, true );
			n.PrintBinary();
			std::vector<std::byte> v_out;
			n.ExportData( v_out, v_in.size(), true );
			std::cout << std::boolalpha << ( v_out == v_in ) << "\n";
		}
		{
			std::vector<uint8_t> v_in = { CHAR_MAX, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
			BigInteger			 n;
			n.ImportData( v_in, false );
			n.PrintBinary();
			std::vector<uint8_t> v_out;
			n.ExportData( v_out, v_in.size(), false );
			std::cout << std::boolalpha << ( v_out == v_in ) << "\n";
		}
		{
			std::vector<uint8_t> v_in = { CHAR_MAX, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
			BigInteger			 n;
			n.ImportData( v_in, true );
			n.PrintBinary();
			std::vector<uint8_t> v_out;
			n.ExportData( v_out, v_in.size(), true );
			std::cout << std::boolalpha << ( v_out == v_in ) << "\n";
		}
	}

	inline void test_prime()
	{
		auto get_random_range = []( const BigInteger& start, const BigInteger& end ) {
			BigInteger range = end - start;
			BigInteger result = BigInteger::RandomGenerateNBit( range.BitLength() + 1 );
			return result % range + start;
		};

		auto miller_rabin = [ & ]( const BigInteger& n ) {
			BigInteger s = n - 1;
			size_t	   t = s.CountTrailingZeros();
			s >>= t;
			BigInteger range = n - 1;
			Montgomery mont( n );
			for ( size_t count = 0; count < 5; count++ )
			{
				BigInteger x = get_random_range( 2, range );
				x = mont.Power( x, s );
				if ( x != 1 )
				{
					size_t i = 0;
					while ( x != range )
					{
						if ( i == t - 1 )
						{
							return false;
						}
						else
						{
							i++;
							x = x * x % n;
						}
					}
				}
			}
			return true;
		};

		auto get_prime = [ & ]( size_t bits ) {
			BigInteger n = BigInteger::RandomGenerateNBit( bits );
			if ( n % 2 == 0 )
			{
				n += 1;
			}
			while ( true )
			{
				if ( miller_rabin( n ) )
				{
					return n;
				}
				n += 2;
			}
		};

		auto	   t1 = std::chrono::steady_clock::now();
		BigInteger a = get_prime( 4096 );
		auto	   t2 = std::chrono::steady_clock::now();
		std::cout << a.ToString( 10 ) << "\n";
		std::cout << std::chrono::duration_cast<std::chrono::milliseconds>( t2 - t1 ).count() << "ms\n";
	}

	void test_custom_data()
	{
		//11111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001100100
		BigInteger BigIntA( std::string( "2135987035920910082279229616932235919179133537347964862161828096540766854433857887501402599587940" ), 10 );
		std::cout << ( BigIntA ).ToString( 10 ) << '\n';

		//110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
		BigInteger BigIntB( std::string( "347376267711948586270712955026063723560490518730763569045299501238602925342721" ), 10 );
		std::cout << ( BigIntB ).ToString( 10 ) << '\n';

		BigInteger BigInt( std::string( "110111000011011101100110101010000000011101000100010000110101011101010010111101001100001011111011100110101001011111100111111100101001010000110001101101100110011100100111000101010101101101100011000000101100010000100101101110101100110001001100011110101000010100010000010001111101110000001001010001110011000001010110010010110000100101010001001010000011111111010111001111001001111100110110011111001001111100000110011110101000001100010001011100" ), 2 );



		std::string s = "10011011100011001110100001101001001110010110100010011000111011010011001110111010011001101000010001111000011000110011000101001011000000101000001110101100100010100001001010000001110101101001110000111011100010011110110000010111101010010110100110010110111000100000101111010001011001000000111010100110101011111001010100111110111001010110001001100101001100010111001";
		BigInteger	BigInt2( s, 2 );
		std::cout << ( BigInt ).ToString( 10 ) << '\n';
		std::cout << ( BigInt2 ).ToString( 10 ) << '\n';
		std::string s1 = ( BigInt2 ).ToBinaryString( s.size() );
		BigInt2.PrintBinary();
		std::cout << std::boolalpha << ( s1 == s ) << "\n";



		BigInteger BigInt3 = BigInt * BigInt2;
		std::cout << ( BigInt3 ).ToString( 10 ) << '\n';

		BigInteger BigInt4 = 1;
		std::cout << ( BigInt4 ).ToString( 10 ) << '\n';
		std::cout << ( BigInt4 << 65 ).ToString( 10 ) << '\n';
		std::cout << ( BigInt4 >> 65 ).ToString( 10 ) << '\n';

		BigInteger BigInt5 = BigInt3 / BigInt2;
		std::cout << ( BigInt5 ).ToString( 10 ) << '\n';
		BigInt5 = BigInt3 % BigInt2;
		std::cout << ( BigInt5 ).ToString( 10 ) << '\n';

		BigInteger a( std::string( "92954886144272226508422748985607494822242113154824437401078813385042747067949901651859860368479946491674170000083080144025161531256342758941494917460364850842091578133853999005335255292965596157173040641254113537583491914908827048992208092284195345255689479473817674543987000932406261587307300676405578662323" ), 10 );
		BigInteger b( std::string( "74599219686668942090095870109335690314480457073999460384973076000247479516254955413312224508592790190766740201259197024116492017287848645291084146353750772548897036470406856197137684790343100646496555827510193973380498788840557141041907869129507287348725651090443374888946529531808156214673179460491863894899" ), 10 );
		BigInteger c( std::string( "149198439373337884180191740218671380628960914147998920769946152000494959032509910826624449017185580381533480402518394048232984034575697290582168292707501545097794072940813712394275369580686201292993111655020387946760997577681114282083815738259014574697451302180886749777893059063616312429346358920983727789799" ), 10 );
		auto	   t1 = std::chrono::steady_clock::now();
		a = a.PowerWithModulo( b, c );
		auto t2 = std::chrono::steady_clock::now();
		auto us = std::chrono::duration_cast<std::chrono::microseconds>( t2 - t1 ).count();
		std::cout << a.ToString( 10 ) << "\n";
		std::cout << us << "us\n";
	}

	inline void test_signed_division()
	{
		BigSignedInteger a, b;
		a = BigSignedInteger( "123456789123456789123456789123456789123456789123456789" );
		b = BigSignedInteger( "123456789123456123456789123456" );
		std::string q = "1000000000000005391900051", r = "94608139426199885730471760533";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';

		a = BigSignedInteger( "123456789123456789123456789123456789123456789123456789" );
		b = BigSignedInteger( "-123456789123456123456789123456" );
		q = "-1000000000000005391900052", r = "-28848649697256237726317362923";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';

		a = BigSignedInteger( "-123456789123456789123456789123456789123456789123456789" );
		b = BigSignedInteger( "123456789123456123456789123456" );
		q = "-1000000000000005391900052", r = "28848649697256237726317362923";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';

		a = BigSignedInteger( "-123456789123456789123456789123456789123456789123456789" );
		b = BigSignedInteger( "-123456789123456123456789123456" );
		q = "1000000000000005391900051", r = "-94608139426199885730471760533";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';
		std::cout << "---------------------------------------------------------------------\n";

		a = BigSignedInteger( "123456789123456789123456694515317362923571058651696256" );
		b = BigSignedInteger( "123456789123456123456789123456" );
		q = "1000000000000005391900051", r = "0";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';

		a = BigSignedInteger( "123456789123456789123456694515317362923571058651696256" );
		b = BigSignedInteger( "-123456789123456123456789123456" );
		q = "-1000000000000005391900051", r = "0";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';

		a = BigSignedInteger( "-123456789123456789123456694515317362923571058651696256" );
		b = BigSignedInteger( "123456789123456123456789123456" );
		q = "-1000000000000005391900051", r = "0";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';

		a = BigSignedInteger( "-123456789123456789123456694515317362923571058651696256" );
		b = BigSignedInteger( "-123456789123456123456789123456" );
		q = "1000000000000005391900051", r = "0";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';
		std::cout << "---------------------------------------------------------------------\n";

		a = BigSignedInteger( "123456789123456789123456694515317362923571058651696256" );
		b = BigSignedInteger( "123456789123456789123456694515317362923571058651696257" );
		q = "0", r = "123456789123456789123456694515317362923571058651696256";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';

		a = BigSignedInteger( "123456789123456789123456694515317362923571058651696256" );
		b = BigSignedInteger( "-123456789123456789123456694515317362923571058651696257" );
		q = "-1", r = "-1";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';

		a = BigSignedInteger( "-123456789123456789123456694515317362923571058651696256" );
		b = BigSignedInteger( "123456789123456789123456694515317362923571058651696257" );
		q = "-1", r = "1";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';

		a = BigSignedInteger( "-123456789123456789123456694515317362923571058651696256" );
		b = BigSignedInteger( "-123456789123456789123456694515317362923571058651696257" );
		q = "0", r = "-123456789123456789123456694515317362923571058651696256";
		std::cout << std::boolalpha << ( ( a / b ).ToString( 10 ) == q ) << '\n';
		std::cout << std::boolalpha << ( ( a % b ).ToString( 10 ) == r ) << '\n';
	}

	void test_all()
	{
		test_binary_inout();
		test_shift();
		test_squeeze_leading_bits();
		test_rotate_shift();
		test_binary_and_or_not();

		test_str_inout();
		test_addition();
		test_substraction();
		test_multiplication();
		test_reciprocal_newton();
		test_division_number();
		test_division();
		test_gcd();
		test_exgcd();
		test_modulo_inverse();

		test_montgomery();
		test_power_with_modulo();
		test_byte_export_import();
		test_prime();
		test_signed_division();
	}
}  // namespace TwilightDream::BigInteger::Test